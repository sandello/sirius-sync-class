# Некоторые задачи синхронзиации

## Перед началом работы

Вам понадобится:

* [Visual Studio Code](https://code.visualstudio.com/)
* [Python 3.7+](https://python.org/downloads/windows/)

Склонируйте проект. Откройте проект в VS Code.
Установите `quart`: `pip install -U quart`.

## Понедельник 16.12

### Шаг первый: обмен сообщениями

Запустите сервер -- `python3.7 server1.py` -- и браузер -- `http://localhost:5000`. Перейдите в первый урок.

В браузере откройте "Инструменты для разработчика", в них найдите JS-консоль.
Там вы должны увидеть сообщение "Начали работу!".

Ознакомьтесь с исходных кодом серверной части `server1.py` и исходных кодом страницы `templates/p_1_start.html`.
Убедитесь, что вы понимаете, как работает связка веб-страницы и сервера.

Сделайте упражнение в `templates/p_1_start.html`.

Далее, запустите взамен первого сервера -- второй (`server2.py`). Ознакомьтесь с комментариями в исходном коде.
Изучите отличия в поведении и функциональности.

Наконец, запустите взамен второго сервера -- третий (`server3.py`). Ознакомьтесь с комментариями в исходном коде.
Изучите отличия в поведении и функциональности.

Сделайте упражнение в `server3.py`.

### Шаг второй: монотонный счетчик

**Важно**: второй шаг требует выполненного в `server3.py` упражнения.

Запустите сервер -- `python3.7 server3.py` -- и браузер -- `http://localhost:5000`. Перейдите во второй урок.

Реализуйте монотонный счетчик: который умеет только расти. Для этого вспомните разобранную на занятии модель счетчика.
Следуйте указаниям в `templates/p_2_inc_counter.html`.

### Шаг третий: обычный счетчик

Это ваше домашнее задание.

Во-первых, доделайте классную работу и доведите обычный счетчик до рабочего состояния.

Во-вторых, добавьте операцию *уменьшения* счетчика.

Попробуйте самостоятельно адаптировать заготовку из `templates/p_2_inc_counter.html`:

* добавить две кнопки -- увеличения и уменьшения счетчика;
* адаптировать тестовый сценарий для нажатия двух кнопок попеременно.

## Вторник 17.12

**Важно**: можно воспользоваться сервером `server4.py`, так как он содержит всю разработанную ранее функциональность.

### Шаг четвертый: правки по Левенштейну

Ваша задача -- реализовать функцию расчета списка правок, которые переводят одну строку в другую.
Правка -- это операция вставки символа, операция удаления символа и операция замены символа.

Чтобы реализовать функцию расчета списка правок вам нужно модифицировать алгоритм расчета
расстояние Левенштейна между двумя строками и добавить в него обратный ход, извлекающий правки.

Сигнатура функции должна быть такая:

```js
function editList(left, right);
```

Исходный код функции должен быть размещен в файле `templates/j_editlist.js`.
Это нужно, чтобы код можно было переиспользовать на шаге 6.

Остальные подробности -- см. в `templates/p_4_editlist.html`.

### Шаг пятый: модель документа

Ваша задача -- реализовать модель документа, поддерживающую операции вставки, удаления и замены,
но использующую абсолютное позиционирование символов внутри. Также модель документа должна
сериализоваться в пару множеств D1 и D2: D1 -- множество пар (позиция, символ), D2 -- множество
удаленных позиций.

Сигнатуры функций модели документа такие:

```js
function public_newDocument() {}
function public_getContent(document) {}

function public_serializeState(document) {} // можно отложить реализацию до 7-го шага
function public_mergeWithSerializedState(document, serializedState) {} // можно отложить реализацию до 7-го шага

function public_insertAfter(document, index, symbol) {} // реализация фиксирована, не трогать
function public_remove(document, index) {} // реализация фиксирована, не трогать
function public_replace(document, index, symbol) {} // реализация фиксирована, не трогать

function _getPositionByIndex(document, index) {}
function _allocate(document, begin, end) {}
function _allocateLeft(document, begin, end) {}
function _allocateRight(document, begin, end) {}
function _applyInsert(document, position, symbol) {}
function _applyRemove(document, position) {}
```

Исходный код функции должен быть размещен в файле `templates/j_treedoc.js`.
Это нужно, чтобы код можно было переиспользовать на шаге 6.

Описание функций, указания и другие подробности -- в `templates/p_5_treedoc.html`.

## Четверг 19.12

### Шаг шестой: интегрируем текстовое поле и модель документа

Ваша задача -- состыковать код из четвертого и пятого шагов.

В заготовке вас ждет интерфейс с текстовым полем. При изменении текстового поля
в нижней части экрана с помощью функции `editList` из `templates/j_editlist.js`
пересчитывается список правок между текущим содержимым модели (правая часть экрана)
и текущим содержимым текстового поля (левая часть экрана).

Вам нужно реализовать логику за кнопкой "Перенести в модель", которая приведет
содержимое модели к такой же строке, что и в текстовом поле.

Указания и подробности -- см. в `templates/p_6_textarea.html`.

### Шаг седьмой: собираем воедино

Ваша задача -- взять наработки с шестого шага и добавить пересылку данных
при изменении модели документа.

Стартовый шаблон и указания -- см. `templates/p_7_integration.html`.

Код работы с сетью можно позаимствовать из первых трех шагов.
Код для работы с текстовым полем -- из шестого.

Это задание для самостоятельной разработки.

## Пятница 20.12

### Улучшение 1: непрыгающий курсор

Чтобы решить проблему прыгающего курсора при синхронизации, нужно сделать следующее:

Во-первых, в `j_treedoc.js` реализовать функцию:

```js
function _getIndexByPosition(document, position) {
    // Вернуть индекс по указанной позиции.
    // То есть вернуть число неудаленных символов, которые предшествуют данной позиции.
}
```

Тесты для проверки следующий:

```js
function testPositionSync1() {
    let d = public_newDocument();
    public_insertAfter(d, -1, "c");
    public_insertAfter(d,  0, "a");
    public_insertAfter(d,  1, "t");
    assertEquals(public_getContent(d), "cat");
    for (var i = -1; i <= 3; ++i) {
        assertEquals(i, _getIndexByPosition(d, _getPositionByIndex(d, i)));
    }
}
```

Во-вторых, улучшить интеграцию между текстовым полем и моделью.

Работа с курсором строится через работу с выделенной областью -- selection range.
Это пара чисел, определяющих диапазон выделенного текста. Если диапазон пустой,
то есть левая и правая границы совпадают, то диапазон кодирует точку расположения курсора.

Наша задача состоит в том, чтобы сохранить диапазон выделения на этапе синхронизации.

Для получения выделенной области используйте следующий код:

```js
var start = $("#integration-textarea").prop("selectionStart");
var end = $("#integration-textarea").prop("selectionEnd");
console.log("Курсор находится в позиции (" + start + ", " + end + ")");
```

Для обновления выделенной области используйте следующий код:

```js
$("#integration-textarea").get()[0].setSelectionRange(start, end);
```

Таким образом, чтобы решить задачу сохранения положения курсора,
код синхронизации нужно модифицировать примерно так:

```js
var startIndex = $("#integration-textarea").prop("selectionStart");
var startPosition = _getPositionByIndex(document, startIndex);
var endIndex = $("#integration-textarea").prop("selectionEnd");
var endPosition = _getPositionByIndex(document, endIndex);
// можно проверить, что startPosition <= endPosition

// здесь код синхронизации

startIndex = _getIndexByPosition(startPosition);
endIndex = _getIndexByPosition(endPosition);

$("#integration-textarea").get()[0].setSelectionRange(startIndex, endIndex);
```
